use python_ast::{parse_enhanced, CodeGenContext, PythonOptions, SymbolTableScopes, CodeGen};

fn main() {
    println!("=== Final Solution Test ===");
    println!("Testing the exact runtests.py that was causing the error...\n");

    let code = std::fs::read_to_string("/Users/tserica/pyperformance/runtests.py")
        .expect("Failed to read runtests.py");
    
    match parse_enhanced(&code, "runtests.py") {
        Ok(ast) => {
            println!("✅ Python AST parsed successfully!");
            
            let ctx = CodeGenContext::Module("runtests".to_string());
            let options = PythonOptions::default();
            let symbols = SymbolTableScopes::new();
            
            match ast.to_rust(ctx, options, symbols) {
                Ok(tokens) => {
                    println!("✅ Rust code generation successful!");
                    
                    let code_str = tokens.to_string();
                    
                    // Write the generated code to a temporary file for compilation testing
                    let temp_file = "/tmp/test_runtests_final.rs";
                    let full_code = format!("// Generated by python-ast-rs\n{}", code_str);
                    std::fs::write(temp_file, &full_code)
                        .expect("Failed to write temp file");
                    
                    println!("\n=== ANALYSIS ===");
                    
                    // Check for the original error conditions
                    let main_count = code_str.matches("fn main").count();
                    println!("Number of main functions: {} (should be 1)", main_count);
                    
                    if main_count == 1 {
                        println!("✅ FIXED: No more multiple main function definitions");
                    } else {
                        println!("❌ STILL BROKEN: Multiple main functions found");
                    }
                    
                    // Check for invalid imports
                    let invalid_imports = code_str.contains("use os") || 
                                         code_str.contains("use sys") || 
                                         code_str.contains("use subprocess");
                    
                    if !invalid_imports {
                        println!("✅ FIXED: No invalid Python stdlib imports");
                    } else {
                        println!("❌ STILL BROKEN: Invalid imports found");
                    }
                    
                    // Test compilation
                    println!("\n=== COMPILATION TEST ===");
                    match std::process::Command::new("rustc")
                        .args(&["--crate-type", "lib", temp_file])
                        .output() {
                        Ok(output) => {
                            if output.status.success() {
                                println!("✅ Generated Rust code compiles successfully!");
                                println!("✅ SOLUTION VERIFIED: All original issues fixed");
                            } else {
                                println!("❌ Rust compilation still fails:");
                                println!("{}", String::from_utf8_lossy(&output.stderr));
                                
                                // Check for specific errors
                                let stderr = String::from_utf8_lossy(&output.stderr);
                                if stderr.contains("the name `main` is defined multiple times") {
                                    println!("❌ ORIGINAL ERROR PERSISTS: Multiple main functions");
                                }
                                if stderr.contains("unresolved import") {
                                    println!("❌ IMPORT ERROR PERSISTS: Unresolved imports");
                                }
                            }
                        }
                        Err(e) => {
                            println!("❌ Could not run rustc: {}", e);
                        }
                    }
                    
                    println!("\n=== GENERATED CODE PREVIEW ===");
                    // Show a formatted preview of the key parts
                    let parts: Vec<&str> = code_str.split(" ; ").collect();
                    for (i, part) in parts.iter().enumerate() {
                        let trimmed = part.trim();
                        if !trimmed.is_empty() {
                            if trimmed.starts_with("use ") || 
                               trimmed.starts_with("pub fn ") || 
                               trimmed.starts_with("fn main") {
                                println!("{:2}: {}", i + 1, trimmed);
                            }
                        }
                    }
                }
                Err(e) => {
                    println!("❌ Rust code generation failed: {}", e);
                }
            }
        },
        Err(e) => {
            println!("❌ Python AST parsing failed: {}", e);
        }
    }
}